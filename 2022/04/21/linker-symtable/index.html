



<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="やがて、平凡な人になる" href="http://sugarsbn.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="やがて、平凡な人になる" href="http://sugarsbn.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="やがて、平凡な人になる" href="http://sugarsbn.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://sugarsbn.github.io/2022/04/21/linker-symtable/">



  <title>
链接（基于 x86-64 下标准 ELF 格式） - - 计算机基础 |
SuBonan = やがて、平凡な人になる</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">链接（基于 x86-64 下标准 ELF 格式）
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-04-21 09:30:37">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-04-21T09:30:37+08:00">2022-04-21</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>10k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>9 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">SuBonan</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5RyI.jpg"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5E3b.png"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/QUTy1.png"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5Qhl.png"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5LGP.png"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5ghr.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="In - 计算机基础"><span itemprop="name">- 计算机基础</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-Hans">
  <link itemprop="mainEntityOfPage" href="http://sugarsbn.github.io/2022/04/21/linker-symtable/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="SuBonan">
    <meta itemprop="description" content=", やがて、平凡な人になる <br><a target="_blank" rel="noopener" href="http://www.subonan.com/computer-graphics"> 图形学作业请点这里 </a>">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="やがて、平凡な人になる">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>感情也存在着可以瞒骗的倾斜的限度。</p>
<p>说起来，就好像桌上放的铅笔滚动之后才开始觉察到桌子倾斜，滴在地板上的水珠流淌起来后才知道地板倾斜，感情的倾斜大类如此。</p>
<span id="more"></span>
<h1 id="从源代码c到可执行文件aout"><a class="markdownIt-Anchor" href="#从源代码c到可执行文件aout">#</a> 从源代码 (.c) 到可执行文件 (a.out)</h1>
<p>当我们在 ubuntu 下敲出命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gcc test.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure>
<p>时，会自动在目录下生成一个可执行的文件 <code>a.out</code> ，然后执行它。然而这个过程却顺序地需要五个工具：</p>
<ul>
<li><strong>Preprocessor</strong>（预处理器）：预处理代码文件（不能说是程序），譬如将宏定义展开。</li>
<li><strong>Compiler</strong>（编译器）：将预处理后的代码文件翻译成汇编代码（Assembly code）。有时也会进行一定的优化。此时文件变为（*.s）</li>
<li><strong>Assembler</strong>（汇编器）：将汇编代码翻译成机器代码（Machine code），此时文件变为目标文件（object file, *.o)</li>
<li><strong>Linker</strong>（链接器）：将目标文件（object file）、libraries 链接起来，也是这我要讨论的内容。</li>
<li><strong>Loader</strong>（装入程序）：执行可执行文件（Executable file, a.out) 时，将所需的数据和指令装入内存，并开始执行。</li>
</ul>
<p>考虑下面这个 C 的代码文件（test.c）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> not_ini;</span><br><span class="line"><span class="type">int</span> ini = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="type">int</span> local = <span class="number">1</span>;</span><br><span class="line">    not_init = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，执行<strong> Preprocessor</strong>，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cpp test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>其中，cpp 是 C Preprocessor 的缩写。然后会得到一个（.i）文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">10</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> not_ini;</span><br><span class="line"><span class="type">int</span> ini = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="type">int</span> local = <span class="number">1</span>;</span><br><span class="line">    not_init = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现它就比原始代码文件多了些头部的信息。</p>
<p>然后，继续执行<strong> Compiler</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cc test.i -o test.s -S</span><br></pre></td></tr></table></figure>
<p>cc 本应该是 C Compiler 的缩写，但是现在已经集成化成 gcc 了。书上写的命令是用的 cc1，目前这个工具也不可见了。事实上，现在可以用 gcc 的不同参数 -S, -E, -O 来分步查看。test.s 里的内容就是很多汇编代码和一点其他内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.comm	not_ini,4,4</span><br><span class="line">	.globl	ini</span><br><span class="line">	.data</span><br><span class="line">	.align 4</span><br><span class="line">	.type	ini, @object</span><br><span class="line">	.size	ini, 4</span><br><span class="line">ini:</span><br><span class="line">	.long	3</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	f@PLT</span><br><span class="line">	movl	$1, -4(%rbp)</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">	.section	.note.gnu.property,&quot;a&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 1f - 0f</span><br><span class="line">	.long	 4f - 1f</span><br><span class="line">	.long	 5</span><br><span class="line">0:</span><br><span class="line">	.string	 &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 0xc0000002</span><br><span class="line">	.long	 3f - 2f</span><br><span class="line">2:</span><br><span class="line">	.long	 0x3</span><br><span class="line">3:</span><br><span class="line">	.align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure>
<p>然后执行<strong> Assembler</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ as test.s -o test.o</span><br></pre></td></tr></table></figure>
<p>生成了目标文件 test.o。这个已经是 ELF（Executable and Linkable Format）的文件了，后面会讨论它的格式。</p>
<p>然后执行<strong> Linker</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ld test.o sum.o</span><br></pre></td></tr></table></figure>
<p>其中 f () 函数定义在 sum.c 中，sum.c 也和 test.c 一样预处理，编译，汇编成了 sum.o 文件。</p>
<p>执行完后就生成了 a.out 文件，就已经可以执行了。</p>
<h1 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接">#</a> 静态链接</h1>
<h2 id="executable-and-linkable-format"><a class="markdownIt-Anchor" href="#executable-and-linkable-format">#</a> Executable and Linkable Format</h2>
<p>实际上，感觉很多人挺熟悉编译和汇编的过程，但不熟悉链接的过程。</p>
<p>实际上，之前的 <code>test.o</code>  文件就已经是一个 ELF 格式文件，可以从中读出很多 Linker 需要的信息。</p>
<p>如果在 ubuntu 下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ readelf -a -x .text -x .data test.o &gt; test.elf</span><br></pre></td></tr></table></figure>
<p>就可以得到一个包含.text section 和.data section 的 elf。</p>
<p>注意到，ELF 只是一种格式，满足这样格式的文件就可以被链接和执行。</p>
<p>那么这个格式要求有哪些内容？</p>
<p><img data-src="1.png" alt="1"></p>
<ul>
<li>
<p><code>.text</code>  代码段（正文段）：汇编出来的代码的机器码</p>
</li>
<li>
<p><code>.rodata</code> read only data：只读数据段，譬如 printf 函数里的 format string，或者 switch 语句的 jump table 等。</p>
</li>
<li>
<p><code>.data</code>  数据段：<strong>被初始化</strong>了的全局变量和 static 变量。局部变量不在这里，在运行时的栈中。</p>
</li>
<li>
<p><code>.bss</code> ：<strong>未被初始化</strong>的全局变量和 static 变量。它目前是没被分配地址和空间的（这在后面符号表的讨论还会提到），在执行时会被 loader 分配空间并初始化为 0。</p>
<blockquote>
<p>为什么未被初始化的变量叫 <code>.bss</code> ？</p>
<p>历史原因，bss 原本是”block started by symbol“的缩写，起源于 IBM 704（1957）的汇编语言</p>
</blockquote>
</li>
<li>
<p><code>.symtab</code>  符号表段：<strong>符号表</strong>包括了代码中<strong>定义和引用</strong>了的<strong>函数和全局变量</strong>的信息。它不包括局部变量。</p>
</li>
<li>
<p><code>.rel.text</code> ：记录了代码段里需要被 linker 重定位的<strong>函数</strong>。譬如 <code>.text</code>  里可能会 call 一些只定义但没实现的函数（譬如 test.c 中的 f ()），那么 <code>.rel.text</code>  就要记下来 call 指令的位置。注：.rel.text=relocatable text。</p>
</li>
<li>
<p><code>.rel.data</code> ：记录了代码段里需要被 linker 重定位的<strong>函数</strong>。譬如 test.c 中的 int not_ini;</p>
</li>
<li>
<p><code>.debug</code> ：一些 debug 信息 ==</p>
</li>
<li>
<p><code>.line</code> ：从原始的 C 代码文件到 <code>.text</code>  段里机器码的映射。描述了每一行 C 代码在 <code>.text</code>  的哪里。</p>
</li>
<li>
<p><code>.strtab</code> string table：string table 就是一些字符串，包含了譬如 symtab 中的 name 之类的信息。</p>
</li>
</ul>
<h2 id="symbol-table"><a class="markdownIt-Anchor" href="#symbol-table">#</a> Symbol table</h2>
<p>我们打开上面 <code>readelf</code>  生成的 <code>test.elf</code> ，其中可以看到一个 Symbol table：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 14 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     9: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM not_ini</span><br><span class="line">    10: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 ini</span><br><span class="line">    11: 0000000000000000    36 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND f</span><br></pre></td></tr></table></figure>
<p>我们可以看一下这个表，一共有 8 个字段。</p>
<ul>
<li><code>Num</code> ：Name 在 <code>strtable</code>  中的 offset。</li>
<li><code>Value</code> ：在相关段中的地址偏移量 offset（后续仔细介绍）。</li>
<li><code>Size</code> ：symbol 的大小</li>
<li><code>Type</code> ：symbol 的类型（数据（OBJECT）、函数（FUNC）、数据段（SECTION）等）</li>
<li><code>Bind</code> ：Local or Global</li>
<li><code>Vis</code> ：不知道干嘛不重要</li>
<li><code>Ndx</code> ：<strong>ABS</strong> 表示 不应该重定位的符号；<strong>COM=COMMON</strong> 表示没被初始化且还没被重定位的符号；<strong>UND=UNDEFINED</strong> 表示被引用了却没被定义的符号。其余为数字的表示段号，譬如 Ndx=3 就是 <code>.data</code>  段，Ndx=1 就是 <code>.text</code>  段。</li>
</ul>
<p>然后再看一眼 <code>Value</code>  字段。这需要参考 elf 中的 <code>.data</code>  段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Hex dump of section &#x27;.text&#x27;:</span><br><span class="line"> NOTE: This section has relocations against it, but these have NOT been applied to this dump.</span><br><span class="line">  0x00000000 f30f1efa 554889e5 4883ec10 b8000000 ....UH..H.......</span><br><span class="line">  0x00000010 00e80000 0000c745 fc010000 00b80000 .......E........</span><br><span class="line">  0x00000020 0000c9c3                            ....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hex dump of section &#x27;.data&#x27;:</span><br><span class="line">  0x00000000 03000000                            ....</span><br></pre></td></tr></table></figure>
<p>就会发现，被初始化的全局变量 <code>ini</code>  的 Value 就是 0，表示在 data 段中，偏移量为 0 时，值就是 3。而未被初始化的 <code>not_ini</code>  的 Value 为 4 其实记录了它地址的对齐要求（即存储他的地址需要是 4 的倍数，对齐）。</p>
<h3 id="练习题目"><a class="markdownIt-Anchor" href="#练习题目">#</a> 练习题目</h3>
<p>考虑下面这两个代码文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// m.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> buf[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	swap();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//swap.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> buf[];</span><br><span class="line"><span class="type">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> *bufp1;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	bufp1 = &amp;buf[<span class="number">1</span>];</span><br><span class="line">	temp = *bufp0;</span><br><span class="line">	*bufp0 = *bufp1;</span><br><span class="line">	*bufp1 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么考虑定义的变量在符号表中的行为？</p>
<table>
<thead>
<tr>
<th></th>
<th>.symtab entry?</th>
<th>Symbol type</th>
<th>Module where defined</th>
<th>Section</th>
</tr>
</thead>
<tbody>
<tr>
<td>buf</td>
<td>Yes</td>
<td>extern</td>
<td>m.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp0</td>
<td>Yes</td>
<td>global</td>
<td>swap.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp1</td>
<td>Yes</td>
<td>global</td>
<td>swap.o</td>
<td>COMMON</td>
</tr>
<tr>
<td>swap</td>
<td>Yes</td>
<td>global</td>
<td>swap.o</td>
<td>.text</td>
</tr>
<tr>
<td>temp</td>
<td>No</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="symbol-resolution"><a class="markdownIt-Anchor" href="#symbol-resolution">#</a> Symbol Resolution</h2>
<p>这部分主要讨论，多个模块链接时，怎么定位每个符号在哪里。</p>
<p>首先很显然一个重要的问题就是，如果在多个 module 里定义了同名的符号（全局变量，函数等），Linker 该怎么选择。</p>
<p>实际上，符号被分为了<strong> Strong Symbol</strong> 和<strong> Weak Symbol</strong>。所有被声明但未被初始化，未被实现的符号为 Weak，反之就是 Strong。然后有重名的符号时，Linker 会依照以下规则：</p>
<ul>
<li>多个<strong> Strong Symbol</strong> 同名，直接报错。</li>
<li>一个<strong> Strong Symbol</strong> 和多个<strong> Weak Symbol</strong> 同名，则为那个 Strong 的符号初始化并分配地址，其他 Weak 的都指向同一个地址。</li>
<li>多个<strong> Weak Symbol</strong> 同名，则随便选一个。</li>
</ul>
<p>此时我们可以看一个经典的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据刚刚提到的规则，链接时会把两个 x 都指向同一个，也是 a.o 模块中的 x，因为它是 Strong 的。但是在 f 中修改时，把 x 当作 64 位来赋值，而实际上 x 的地址和 y 的地址只差了 32 位（链接器分配时，将其作为 int），于是 f（）中给 x 赋值实际上也覆盖了 y。</p>
<hr>
<p>另一个问题是，譬如你写了很多个函数作为一个模块，譬如 stdlib，然后别人想引用时，如果也像之前一样链接，会很浪费空间。因为你的模块里可能有成千上万个函数，但是他想引用的就几个。</p>
<p>因此在 Linux 下有了 <code>archive</code>  格式的文件 (.a)，简单地看来他就是模块 (.o) 的合集，被称为<strong>静态链接库</strong>。在链接时，链接器会从中选取引用了的模块进行链接。</p>
<p>你可以制作自己的<strong>静态链接库</strong>，并链接使用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ar rcs libmy.a test.o sum.o</span><br><span class="line">$ ld main.o libmy.a</span><br></pre></td></tr></table></figure>
<p>也可以输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gcc -static test.o -L. -lmy</span><br></pre></td></tr></table></figure>
<p>其中 - static 表示静态链接，-L. 表示在当前目录下搜索，而 - lmy 就是 libmy.a 的缩写。（注意这里必须命名为 libXXX.a 才能用 - lXXX）</p>
<hr>
<p>然后这里有一个非常生草的过程。就是链接器在扫描静态链接库和重定位时，是按照命令行输入的顺序做的。</p>
<p>譬如 main.o 调用了 libx.a 里的函数，libx.a 里的函数又调用了 liby.a 里的函数，而 liby.a 里的函数又调用了 libx.a 里的函数。</p>
<p>那你需要的命令就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$gcc</span> main.o libx.a liby.a libx.a</span><br></pre></td></tr></table></figure>
<p>即你的依赖项需要写在后面。当然，现在一般更好的设计都是静态链接库间是独立的，互不依赖的。</p>
<h2 id="relocation"><a class="markdownIt-Anchor" href="#relocation">#</a> Relocation</h2>
<p>一旦确定了符号是哪个，就要开始分配地址了。</p>
<p>首先，代码的 Relocation Entries 被存在 <code>.rel.text</code>  段，数据的 Relocation Entries 被存在 <code>.rel.data</code>  段。譬如之前的 test.c 的 <code>.rel.text</code>  段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.text&#x27; at offset 0x2a8 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000012  000d00000004 R_X86_64_PLT32    0000000000000000 f - 4</span><br><span class="line">00000000001f  000900000002 R_X86_64_PC32     0000000000000004 not_ini - 8</span><br></pre></td></tr></table></figure>
<p>看下 test 的 main 函数的反汇编：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ objdump -dx test.o &gt; test.asm</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	55                   	push   %rbp</span><br><span class="line">   5:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   8:	48 83 ec 10          	sub    $0x10,%rsp</span><br><span class="line">   c:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  11:	e8 00 00 00 00       	call   16 &lt;main+0x16&gt;</span><br><span class="line">			12: R_X86_64_PLT32	f-0x4</span><br><span class="line">  16:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)</span><br><span class="line">  1d:	c7 05 00 00 00 00 03 	movl   $0x3,0x0(%rip)        # 27 &lt;main+0x27&gt;</span><br><span class="line">  24:	00 00 00 </span><br><span class="line">			1f: R_X86_64_PC32	not_ini-0x8</span><br><span class="line">  27:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  2c:	c9                   	leave  </span><br><span class="line">  2d:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>会发现汇编里留了需要改变的机器码的位置，即需要把 &lt;main+0x12&gt; 改为 f 的入口，把 &lt; main+0x1f &gt; 改为 not_ini 的位置。而这在 Relocation Entries 中也有体现，即 offset 字段。然后还有 Type 字段比较重要：</p>
<ul>
<li><code>R_X86_64_PC32</code> ：表示这是一个和 PC 有关的，32 位地址的 Relocation。实际上是一个 32 位有符号数 offset，再在运行时加上 PC 寄存器的值就得到了真实地址。</li>
<li><code>R_X86_64_32</code> ：表示这是一个 32 位的绝对地址。现在几乎都被 <code>R_X86_64_PLT32</code>  替代。</li>
</ul>
<p><code>addend</code>  是一个有符号数，用来在不同 type 的重定位时修正地址（这看后面例子）。</p>
<hr>
<p>重定位的伪代码算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foreach section s&#123;</span><br><span class="line">    foreach relocation entry r&#123;</span><br><span class="line">		refptr = s + r.offset;</span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_PC32) &#123;</span><br><span class="line">			refaddr = ADDR(s) + r.offset;</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_32) &#123;</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看个例子。譬如下面这个模块的函数里面 call 了一个未实现的 sum（）函数和 array 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">	0:	48 83 ec 08					sub	$0x8,%rsp</span><br><span class="line">	4:	be 02 00 00 00				mov	$0x2,%esi</span><br><span class="line">	9:	bf 00 00 00 00				mov $0x0,%edi</span><br><span class="line">		a: R_X86_64_32 array</span><br><span class="line">	e:	e8 00 00 00 00				callq 13 &lt;main+0x13&gt;</span><br><span class="line">		f: R_X86_64_PC32 sum-0x4</span><br><span class="line">	13: 48 83 c4 08					add $0x8, %rsp</span><br><span class="line">	17: c3							retq</span><br></pre></td></tr></table></figure>
<p>在重定位时，会扫描到下面这个 relocation entry：</p>
<blockquote>
<p>r.offset = 0xf</p>
<p>r.symbol = sum</p>
<p>r.type = R_X86_64_PC32</p>
<p>r.addend = -4</p>
</blockquote>
<p>如果在链接时，分配了 ADDR (s)=ADDR (.text)=0x4004d0，ADDR (r.symbol) = ADDR (sum) = 0x4004e8。注意到这是链接器分配的，而虚拟内存中 0x400000 开始就是正文段和数据段：</p>
<p><img data-src="2.png" alt="2"></p>
<p>根据算法就有：</p>
<blockquote>
<p>refaddr = ADDR(s)+r.offset = 0x4004df</p>
<p>*refpte = (unsigned) (0x4004e8 -4 -0x4004df) = 0x5</p>
</blockquote>
<p>所以地址为 e 的那条指令就变为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4004de:	e8 05 00 00 00		callq 4004e8 &lt;sum&gt;</span><br></pre></td></tr></table></figure>
<p>在运行这条指令后时，PC 寄存器相对这个大模块的偏移地址为 0x4004e3（即 4004de+5，因为这个指令占五个字节），然后再加上 0x5 就正好 call 到了 0x4004e8 处的 sum 函数。</p>
<p>另一个 relocation entry 是：</p>
<blockquote>
<p>r.offset = 0xa</p>
<p>r.symbol = array</p>
<p>r.type = R_X86_64_32</p>
<p>r.addend = 0</p>
</blockquote>
<p>这个就更简单，只需要看链接器给 <code>.data</code>  section 分配的偏移地址，然后就加 0 给 mov 指令就好了。</p>
<h1 id="动态链接"><a class="markdownIt-Anchor" href="#动态链接">#</a> 动态链接</h1>
<p>动态链接和静态链接本质的区别就是静态链接里符号的重定位发生在链接阶段，而动态链接中的符号重定位发生在运行时。</p>
<p>动态链接库被称为<strong> Shared library</strong>（Shared objects），在 linux 是.so 文件。制作自己的动态链接库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gcc -shared -fpic -o libmy.so test.c sum.c</span><br></pre></td></tr></table></figure>
<p>其中，-fpic 参数意思是要求产生<strong> position independent code</strong>。然后就可以使用生成的库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gcc test.c sum.c -c</span><br><span class="line">$ gcc test.o sum.o libmy.so</span><br></pre></td></tr></table></figure>
<p>这样生成的 a.out 用 readelf 打开，里面会有一个.interp 的 section，记录了<strong> dynamic linker</strong> 的位置。而 dynamic linker 自己也是个 shared object（e.g. <span class="exturl" data-url="aHR0cDovL3huLS1MaW51eGxkLWxpbnV4LXQ0MHVzMzI4Yi5zbw==">Linux 下的 ld-linux.so</span>）</p>
<p>事实上，有一种更能体现动态链接库本质的操作，即可以在 C 程序中这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Dynamically load the shared library containing addvec() */</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get a pointer to the addvec() function we just loaded */</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Now we can call addvec() just like any other function */</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Unload the shared library */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 dlopen 函数，我们可以直接在运行时就使用 libvector.so 中的函数 addvec 了。</p>
<h2 id="position-independent-code"><a class="markdownIt-Anchor" href="#position-independent-code">#</a> Position Independent Code</h2>
<p>动态链接库的一大优势就是运行时重定位，可以让多个程序或进程共享同一块内存空间内的库代码，这样可以节省空间。而静态链接是 linker 进行的重定位，因此如果我们多个程序用同一个静态链接库，分别链接的话就会分配多个地址，浪费了空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ld program1.o libmy.a -o program1.out</span><br><span class="line">$ ld program2.o libmy.a -o program2.out</span><br></pre></td></tr></table></figure>
<p>譬如上面这个动态链接库就会导致 program1.out 和 program2.out 的 elf 中，符号的重定位时，即使用到了 libmy.a 中的同一个函数，也会重定位到两个位置。</p>
<p><strong>Code that can be loaded without needing any relocations is known as <em>position independent code</em> (PIC).</strong></p>
<p>这是怎么实现的呢？</p>
<p>首先如果 PIC 里引用了全局变量，这比较简单，因为程序在装入后，data segment 和 code segement 之间的地址总是差一个常数。所以我们可以维护一个<strong> Global Offset Table（GOT）</strong>，它是一个 8 字节的地址数组。这样对全局变量的引用就可以表示为：</p>
<p><img data-src="3.png" alt="3"></p>
<p>如果 PIC 里引用了函数，这需要用到一个 lazy binding 的技术。我们需要一个 **Procedure Linkage Tabel（PLT）** 的表，它是一个 16 字节的地址数组。每个链接库里的函数都在表中有一个 entry。思想就是在第一次 call 库中的函数时，就会通过 GOT 跳进 PLT 对应的项，然后在 PLT 里执行一遍函数后跳到 PLT [0]（PLT [0] 是 dynamic linker），然后就会更新了 GOT 中的值。这样之后 call 同一个函数时，就会直接跳转到函数了。</p>
<p>下左图就是第一次 call addvec () 时的情况，右图是之后再 call 同一个函数的情况。</p>
<p><img data-src="4.png" alt="4"></p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2025-03-30 09:13:16" itemprop="dateModified" datetime="2025-03-30T09:13:16+08:00">2025-03-30</time>
  </span>
  <span id="2022/04/21/linker-symtable/" class="item leancloud_visitors" data-flag-title="链接（基于 x86-64 下标准 ELF 格式）" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>SuBonan <i class="ic i-at"><em>@</em></i>やがて、平凡な人になる
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://sugarsbn.github.io/2022/04/21/linker-symtable/" title="链接（基于 x86-64 下标准 ELF 格式）">http://sugarsbn.github.io/2022/04/21/linker-symtable/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;i.imgtg.com&#x2F;2023&#x2F;01&#x2F;12&#x2F;QUUdI.png" title="操作系统">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> - 计算机基础</span>
  <h3>操作系统</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/04/22/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;i.imgtg.com&#x2F;2023&#x2F;01&#x2F;12&#x2F;Q5mtM.png" title="Numerical Analysis">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> - 数学杂记</span>
  <h3>Numerical Analysis</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81c%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6aout"><span class="toc-number">1.</span> <span class="toc-text"> 从源代码 (.c) 到可执行文件 (a.out)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.</span> <span class="toc-text"> 静态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#executable-and-linkable-format"><span class="toc-number">2.1.</span> <span class="toc-text"> Executable and Linkable Format</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#symbol-table"><span class="toc-number">2.2.</span> <span class="toc-text"> Symbol table</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 练习题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#symbol-resolution"><span class="toc-number">2.3.</span> <span class="toc-text"> Symbol Resolution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#relocation"><span class="toc-number">2.4.</span> <span class="toc-text"> Relocation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text"> 动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#position-independent-code"><span class="toc-number">3.1.</span> <span class="toc-text"> Position Independent Code</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/2020/10/06/%E5%85%B3%E4%BA%8Ejava%E5%9F%9F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E6%80%81%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BC%BA%E9%99%B7/" rel="bookmark" title="关于java域和静态方法不支持多态导致的缺陷">关于java域和静态方法不支持多态导致的缺陷</a></li><li><a href="/2020/11/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/" rel="bookmark" title="基数排序">基数排序</a></li><li><a href="/2021/06/09/C%20C++%20%E8%AF%AD%E6%B3%95/" rel="bookmark" title="C-C++语法">C-C++语法</a></li><li><a href="/2021/10/20/%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/" rel="bookmark" title="类型和程序设计语言">类型和程序设计语言</a></li><li><a href="/2021/11/02/%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%BB%AD/" rel="bookmark" title="类型和程序设计语言_续">类型和程序设计语言_续</a></li><li><a href="/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="操作系统">操作系统</a></li><li class="active"><a href="/2022/04/21/linker-symtable/" rel="bookmark" title="链接（基于x86-64下标准ELF格式）">链接（基于x86-64下标准ELF格式）</a></li><li><a href="/2022/08/28/%E5%85%B3%E4%BA%8EHaskell%E5%AF%B9Kmeans%E7%AE%97%E6%B3%95parallel%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/" rel="bookmark" title="关于Haskell对Kmeans算法parallel并行实现的注释">关于Haskell对Kmeans算法parallel并行实现的注释</a></li><li><a href="/2023/01/05/C-%E6%95%B0%E7%BB%84/" rel="bookmark" title="C++中数组和内存分布">C++中数组和内存分布</a></li><li><a href="/2023/01/11/Machine-Learning/" rel="bookmark" title="Machine Learning 机器学习">Machine Learning 机器学习</a></li><li><a href="/2023/01/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%90%AB%E4%B9%89/" rel="bookmark" title="图形学中的矩阵含义">图形学中的矩阵含义</a></li><li><a href="/2023/02/01/%E7%82%B9%E7%BA%BF%E9%9D%A2%E7%9A%84%E6%8F%92%E5%80%BC/" rel="bookmark" title="点线面的插值">点线面的插值</a></li><li><a href="/2023/02/11/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" rel="bookmark" title="光照模型">光照模型</a></li><li><a href="/2023/02/11/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E4%BC%98%E5%8C%96/" rel="bookmark" title="汇编语言乱七八糟的优化">汇编语言乱七八糟的优化</a></li><li><a href="/2023/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="bookmark" title="计算机网络">计算机网络</a></li><li><a href="/2023/06/14/Database/" rel="bookmark" title="Introduction to Database">Introduction to Database</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="SuBonan"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">SuBonan</p>
  <div class="description" itemprop="description">やがて、平凡な人になる <br><a target="_blank" rel="noopener" href="http://www.subonan.com/computer-graphics"> 图形学作业请点这里 </a></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">114</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">10</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">2</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1Z2FyU0JO" title="https:&#x2F;&#x2F;github.com&#x2F;SugarSBN"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/04/22/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="In - 计算机基础">- 计算机基础</a>
</div>

    <span><a href="/2023/06/14/Database/" title="Introduction to Database">Introduction to Database</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2023/04/30/Savitch-theorem/" title="Savitch&#39;s Theorem">Savitch's Theorem</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2022/11/14/Fiberation/" title="Fibration">Fibration</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2020/12/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F/" title="离散数学-代数系统">离散数学-代数系统</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2023/11/08/ABFEx/" title="Analysis of Boolean Function （Course Exercise Solutions)">Analysis of Boolean Function （Course Exercise Solutions)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/" title="In - 量子计算">- 量子计算</a>
</div>

    <span><a href="/2023/03/13/Kraus-theorem/" title="Kraus Theorem">Kraus Theorem</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%BB%98%E7%94%BB/" title="In - 绘画">- 绘画</a>
</div>

    <span><a href="/2021/02/14/%E8%89%B2%E5%BD%A9/" title="色彩">色彩</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2023/06/01/sublinear-algorithms/" title="Sublinear Algorithms">Sublinear Algorithms</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/" title="In - 程序语言理论">- 程序语言理论</a>
</div>

    <span><a href="/2021/09/27/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%EF%BC%88%E7%BB%AD%EF%BC%89/" title="程序设计语言的形式语义（续）">程序设计语言的形式语义（续）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%82%E6%84%9F/" title="In - 杂感">- 杂感</a>
</div>

    <span><a href="/2019/08/21/%E7%BA%AA%E5%BF%B5%E5%BE%90%E5%AD%90%E7%84%93/" title="纪念徐子焓">纪念徐子焓</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SuBonan @ SuBonan</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/04/21/linker-symtable/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>

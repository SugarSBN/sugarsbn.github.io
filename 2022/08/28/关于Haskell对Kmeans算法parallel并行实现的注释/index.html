



<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="やがて、平凡な人になる" href="http://sugarsbn.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="やがて、平凡な人になる" href="http://sugarsbn.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="やがて、平凡な人になる" href="http://sugarsbn.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://sugarsbn.github.io/2022/08/28/%E5%85%B3%E4%BA%8EHaskell%E5%AF%B9Kmeans%E7%AE%97%E6%B3%95parallel%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/">



  <title>
关于 Haskell 对 Kmeans 算法 parallel 并行实现的注释 - - 计算机基础 |
SuBonan = やがて、平凡な人になる</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">关于 Haskell 对 Kmeans 算法 parallel 并行实现的注释
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-08-28 18:12:26">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-08-28T18:12:26+08:00">2022-08-28</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>19k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>18 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">SuBonan</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5tsD.jpg"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5ghr.jpg"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5dWs.jpg"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5LGP.png"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5lrN.jpg"></li>
          <li class="item" data-background-image="https://i.imgtg.com/2023/01/12/Q5pjG.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="In - 计算机基础"><span itemprop="name">- 计算机基础</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-Hans">
  <link itemprop="mainEntityOfPage" href="http://sugarsbn.github.io/2022/08/28/%E5%85%B3%E4%BA%8EHaskell%E5%AF%B9Kmeans%E7%AE%97%E6%B3%95parallel%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="SuBonan">
    <meta itemprop="description" content=", やがて、平凡な人になる <br><a target="_blank" rel="noopener" href="http://www.subonan.com/computer-graphics"> 图形学作业请点这里 </a>">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="やがて、平凡な人になる">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>认真学语言可能就需要仔细读代码和了解各种语法和库函数吧</p>
<span id="more"></span>
<p>原本只是在看 Parallel and Concurrent programming，结果看到一个 example 发现好多语法和库函数还不会，看来还是不够了解 Haskell 语言。</p>
<p>趁此机会正好踏实地一点一点看一下，看懂了还是觉得有的实现挺奇妙的，一行信息量更比六行多。</p>
<h1 id="kmeanscore"><a class="markdownIt-Anchor" href="#kmeanscore">#</a> KMeansCore</h1>
<p>首先是 KMeansCore module，代码如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Adapted from the K-Means example in the remote-0.1.1 package,</span></span><br><span class="line"><span class="comment">--   (c) Jeff Epstein &lt;jepst79@gmail.com&gt;</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveDataTypeable #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> KMeansCore <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="keyword">import</span> Data.Typeable (<span class="type">Typeable</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Data (<span class="type">Data</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.ByteString.Char8 <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">import</span> Data.Binary</span><br><span class="line"><span class="keyword">import</span> Control.DeepSeq</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Points</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="meta">&#123;-#UNPACK#-&#125;</span>!<span class="type">Double</span> <span class="meta">&#123;-#UNPACK#-&#125;</span>!<span class="type">Double</span></span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Show</span>,<span class="type">Read</span>,<span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- deepseq changed in GHC 7.10 to use Generic instances, so for backwards</span></span><br><span class="line"><span class="comment">-- compatibility define it manually.</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">NFData</span> <span class="type">Point</span> <span class="keyword">where</span></span></span><br><span class="line">  rnf (<span class="type">Point</span> x y) = () <span class="comment">-- all fields are strict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;point-ops</span></span><br><span class="line"><span class="title">zeroPoint</span> :: <span class="type">Point</span></span><br><span class="line"><span class="title">zeroPoint</span> = <span class="type">Point</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">sqDistance</span> :: <span class="type">Point</span> -&gt; <span class="type">Point</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">sqDistance</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2) = ((x1-x2)^<span class="number">2</span>) + ((y1-y2)^<span class="number">2</span>)</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Binary</span> <span class="type">Point</span> <span class="keyword">where</span></span></span><br><span class="line">  put (<span class="type">Point</span> a b) = <span class="keyword">do</span></span><br><span class="line">                        put a</span><br><span class="line">                        put b</span><br><span class="line">  get = <span class="keyword">do</span> </span><br><span class="line">            a &lt;- get </span><br><span class="line">            b &lt;- get </span><br><span class="line">            return (<span class="type">Point</span> a b)</span><br><span class="line"></span><br><span class="line"><span class="title">readPoints</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IO</span> [<span class="type">Point</span>]</span><br><span class="line"><span class="title">readPoints</span> f = <span class="keyword">do</span></span><br><span class="line">                    s &lt;- <span class="type">B</span>.readFile f</span><br><span class="line">                    <span class="keyword">let</span> ls = map <span class="type">B</span>.words $ <span class="type">B</span>.lines s</span><br><span class="line">                        points = [ <span class="type">Point</span> (read (<span class="type">B</span>.unpack sx)) (read (<span class="type">B</span>.unpack sy))</span><br><span class="line">                                | (sx:sy:_) &lt;- ls ]</span><br><span class="line">                    <span class="comment">--</span></span><br><span class="line">                    return points</span><br><span class="line"></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Clusters</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Cluster</span></span></span><br><span class="line">  = <span class="type">Cluster</span> &#123; clId    :: <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Int</span></span><br><span class="line">            , clCent  :: <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Point</span></span><br><span class="line">            &#125;</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>,<span class="type">Read</span>,<span class="type">Eq</span>)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">NFData</span> <span class="type">Cluster</span> <span class="keyword">where</span></span></span><br><span class="line">  rnf (<span class="type">Cluster</span> id cent) = () <span class="comment">-- all fields are strict</span></span><br><span class="line"></span><br><span class="line"><span class="title">makeCluster</span> :: <span class="type">Int</span> -&gt; [<span class="type">Point</span>] -&gt; <span class="type">Cluster</span></span><br><span class="line"><span class="title">makeCluster</span> clid points =</span><br><span class="line">  <span class="type">Cluster</span> &#123; clId    = clid</span><br><span class="line">          , clCent  = <span class="type">Point</span> (a / fromIntegral count) (b / fromIntegral count)</span><br><span class="line">          &#125;</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">  pointsum @ (<span class="type">Point</span> a b) = foldl&#x27; addPoint zeroPoint points</span><br><span class="line">  count = length points</span><br><span class="line"></span><br><span class="line">  addPoint :: <span class="type">Point</span> -&gt; <span class="type">Point</span> -&gt; <span class="type">Point</span></span><br><span class="line">  addPoint (<span class="type">Point</span> a b) (<span class="type">Point</span> c d) = <span class="type">Point</span> (a+c) (b+d)</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>关于程序头部的</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveDataTypeable #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际上是 Haskell 的一个 <code>pragma system</code> ，可以起到对编译器提供额外语言信息的作用。通用语法为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# &lt;NAME&gt; &lt;ARGS...&gt; #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>一般的 pragma 如果忽略是不影响程序编译运行的，但是 <code>LANGUAGE</code>  program 稍有特殊，但它的作用仍然是声明接下来写的语言是怎样的。而在 GHC 的手册上可以查到不同的 pragma 的作用：<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZHMuaGFza2VsbC5vcmcvfmdoYy84LjQuMy9kb2NzL2h0bWwvdXNlcnNfZ3VpZGUvZ2xhc2dvd19leHRzLmh0bWw=">https://downloads.haskell.org/~ghc/8.4.3/docs/html/users_guide/glasgow_exts.html</span></p>
<p><img data-src="1.png" alt="1"></p>
</li>
<li>
<p>关于类型声明中，出现了 &quot;!&quot; 感叹号。由于 Haskell 是 lazy evaluate 的，你声明一个变量 p = Point (3+4) 5 的时候，表达式（3+4）是不会被计算的，直至必须的时候（譬如 print (show p) 的时候）。这样会有一个问题就是和我们的习惯不同，如果你不断声明就会导致非常占用内存，我们有时是希望他 urge evaluating 的，就一开始就把表达式值算出来。</p>
<p>所以使用了感叹号标记的 <code>!Int</code>  后，就可以满足我们的要求。</p>
<p>然后会发现这里也出现了 pragma：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# UNPACK #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际上，我查到</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="meta">&#123;-# UNPACK -#&#125;!Double &#123;-# UNPACK #-&#125;</span>!<span class="type">Double</span></span></span><br></pre></td></tr></table></figure>
<p>是一种非常严格和标准的写法。见问题：“<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTA0NjA0OTMvd2h5LWlzLWl0LWNvbW1vbi10by1tYXJrLXJlY29yZC1maWVsZHMtd2l0aC11bnBhY2stYW5kLXN0cmljdG5lc3M=">Why is it common to mark record fields with UNPACK and strictness?</span>”</p>
<p>其中 <code>UNPACK</code>  pragma 的作用可以用一个例子解释：</p>
<p><img data-src="2.png" alt="2"></p>
<p>上左图是声明</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">P</span> = <span class="type">P</span> !<span class="type">Int</span> !<span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> = <span class="type">T</span> <span class="type">P</span></span></span><br></pre></td></tr></table></figure>
<p>的情况，右图是声明</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">P</span> = <span class="type">P</span> !<span class="type">Int</span> !<span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> = <span class="type">T</span> <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">P</span></span></span><br></pre></td></tr></table></figure>
<p>的情况，本质上还是为了不要因为 type constructor 嵌套太多层，导致占用大量内存。</p>
</li>
<li>
<p>关于 type class  <code>NFData</code> ，在 Hoogle 上的解释为</p>
<blockquote>
<p>A class of types that can be fully evaluated.</p>
</blockquote>
<p>就是可以完全推算出值的一组数据类型，实际上我们常用的和能想到的都满足。它只要求一个方法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rnf</span>::<span class="type">NFData</span> a =&gt; a -&gt; ()</span><br></pre></td></tr></table></figure>
<p>rnf 应该是 “reduce to normal form” 的简称，该方法实际上就是要求你给出怎么把该数据类型规约成 normal form。譬如</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Pair</span> = <span class="type">Pair</span> <span class="type">Int</span> <span class="type">Int</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">NFData</span> <span class="type">Pair</span> <span class="keyword">where</span></span></span><br><span class="line">  rnf (<span class="type">Pair</span> a b) = (rnf a) `seq` (rnf b)</span><br></pre></td></tr></table></figure>
<p>上述代码的意思为 “要规约 Pair 类型，即先规约 Pair 的第一个 Int，再规约 Pair 的第二个 Int”。同时也表达了 “当 Pair 类型的两个 Int 参数都是 normal form 时，我们认为这个 Pair 类型也是 normal form”。</p>
<p>而在原代码中，由于使用了 “！” 标记，即该 Double 本身就已经被 urge evaluate 了，所以注释写了 “all fields are strict”，故<strong>声明的 Point 类型实例均为 normal form</strong>，用代码表示就是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rnf</span> _ = ()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关于 type class  <code>Binary</code> 。Hackage 上查到的说明为：</p>
<blockquote>
<p>Binary serialisation of Haskell values to and from lazy  <code>ByteString</code> s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting  <code>ByteString</code>  can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</p>
<p>The  <code>binary</code>  package is notable in that it provides both pure, and high performance serialisation.</p>
</blockquote>
<p>而需要我们实现的方法是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">put</span> :: t -&gt; <span class="type">Put</span></span><br><span class="line"><span class="title">get</span> :: <span class="type">Get</span> t</span><br></pre></td></tr></table></figure>
<p>就是让我们实现一组编码 / 解码的方法。其中系统已经帮我们实现好了 Int 类型的编码 / 解码方法（具体怎么做的我也不知道，打印出来目测是大端法不知道咋编的），所以如果我们想对 Point 类型编码 / 解码，实际上就是对 Point 的两个 Int field 进行编码 / 解码，而 Put，Get 都是 Monad，故有了原代码中的写法。</p>
<p>实现了 put 和 get 后，就可以使用下面两个函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">encode</span> :: t -&gt; <span class="type">ByteString</span></span><br><span class="line"><span class="title">decode</span> :: <span class="type">ByteString</span> -&gt; t</span><br></pre></td></tr></table></figure>
<p>类型签名我写的比较随意严格来说不是这个，但不影响理解。其中 <code>ByteString</code>  类型介绍如下：</p>
<blockquote>
<p>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict  <code>Word8</code>  arrays of bytes, held in a  <code>ForeignPtr</code> , and can be passed between C and Haskell with little effort.</p>
</blockquote>
<p>实际上是通过某种编码，获得了比 <code>String</code>  更高性能的表现。</p>
<p><strong>总之目前发现如果一个类型需要往文件中读写的话，实现一下 instance Binary 是很不错的。</strong></p>
</li>
<li>
<p>关于 <code>readFile</code>  等一系列文件操作。</p>
<p>首先有</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">FilePath</span> = <span class="type">String</span></span></span><br></pre></td></tr></table></figure>
<p>很好理解，就是文件目录就是个字符串，然后</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">readFile</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IO</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>很朴素的函数，从文件中读东西就返回一个字符串，然后由于可能有 side effect 所以套了个 IO Monad。然后</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lines</span> :: <span class="type">String</span> -&gt; [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p>就是分行函数，把一个 String 按照分行符 “\n”，&quot;\r\n&quot; 分成多个 String。然后</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">words</span> :: <span class="type">String</span> -&gt; [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p>就是根据制表符，空格等把一个 String 分成若干个单词。</p>
<p>然后后面会看到我们会把生成的点 encode 成二进制文件 “points.bin”，所以读出来后需要用 <code>unpack</code>  函数解码一下。而 read 函数就比较常见了。</p>
</li>
<li>
<p>关于符号 &quot;@&quot;。其实是类似于同位语符号。形如如下声明：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">p</span> @ (<span class="type">Point</span> a b)</span><br></pre></td></tr></table></figure>
<p>实际上给了三个能用的变量：p, a, b，且 p = Point a b。</p>
<p>如果不这么写，可能 where p = XXX 后，还需要单独写一个函数来提取 Point 的 field，形如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getX</span> :: <span class="type">Point</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">getX</span> (<span class="type">Point</span> <span class="type">X</span> <span class="type">Y</span>) = <span class="type">X</span></span><br><span class="line"></span><br><span class="line"><span class="title">getY</span> :: <span class="type">Point</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">getY</span> (<span class="type">Point</span> <span class="type">X</span> <span class="type">Y</span>) = <span class="type">Y</span></span><br></pre></td></tr></table></figure>
<p>就很麻烦，然后用 &quot;@&quot; 后就没事了，就可以直接 where p @ (Point a b) = XXX 然后直接用 a 和 b 了。</p>
</li>
<li>
<p>关于 <code>foldl'</code>  函数。我们先考虑 <code>foldl</code>  和 <code>foldr</code>  的区别，它们的类型签名都是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> :: <span class="type">Foldable</span> t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br></pre></td></tr></table></figure>
<p>最常用的 t 当然就是列表 “[]”。而</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> f initial [a]</span><br></pre></td></tr></table></figure>
<p>实际上就是给一个初始值 initial，然后把他和列表 [a] 中所有元素都一个一个作 f 运算，最后返回一个结果。譬如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> (+) <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>就是初始值是 0，然后把列表元素一个一个加到 0 上。</p>
<p>而 <code>foldl</code>  和 <code>foldr</code>  的区别就是这个函数的实现，目的都是相同的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> f i (x : xs) = foldl f (f i x) xs</span><br><span class="line"><span class="title">foldr</span> f i (x : xs) = f i (foldr f x xs)</span><br></pre></td></tr></table></figure>
<p>仔细理解下就会发现，foldl 想法是把 initial value 和列表元素第一个作运算后，放入列表里继续 fold；</p>
<p>foldr 是先把剩余的列表都 fold 了，再和 initial value 作运算。</p>
<p>那么 <code>foldl'</code>  是什么呢？看他的实现就是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> f i (x : xs) = <span class="keyword">let</span> z = (f i x) <span class="keyword">in</span> z `seq` foldl&#x27; f z&#x27; xs</span><br></pre></td></tr></table></figure>
<p>就是强迫进行 urge evaluating。如果用 foldl，那么 (f i x) 的值并不会算出来，而是保留一个表达式，但是用 foldl’实际上就会强迫先算出 (f i x) 的值，再进行下一步 fold。</p>
<p>举个例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> (+) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] = ((((<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>但用 foldl’就不会那么多层嵌套，而是算出一个值再计算下一个，可以有效避免 stack overflow 的问题。其实能用 foldl’都用就好了。</p>
</li>
</ol>
<h1 id="gensample"><a class="markdownIt-Anchor" href="#gensample">#</a> GenSample</h1>
<p>然后是 GenSample module，代码如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> GenSample <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> KMeansCore</span><br><span class="line"><span class="keyword">import</span> Data.Random.Normal</span><br><span class="line"><span class="keyword">import</span> System.Random</span><br><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"><span class="keyword">import</span> Data.Array</span><br><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="keyword">import</span> Data.Binary</span><br><span class="line"></span><br><span class="line"><span class="title">minX</span>, maxX, minY, maxY, minSD, maxSD :: <span class="type">Double</span></span><br><span class="line"><span class="title">minX</span> = -<span class="number">10</span></span><br><span class="line"><span class="title">maxX</span> = <span class="number">10</span></span><br><span class="line"><span class="title">minY</span> = -<span class="number">10</span></span><br><span class="line"><span class="title">maxY</span> = <span class="number">10</span></span><br><span class="line"><span class="title">minSD</span> = <span class="number">1.5</span></span><br><span class="line"><span class="title">maxSD</span> = <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="title">genMain</span> :: [<span class="type">String</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">genMain</span> args = <span class="keyword">do</span></span><br><span class="line">                    <span class="keyword">let</span> n: minp: maxp: rest = (map read) args</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> rest <span class="keyword">of</span></span><br><span class="line">                        [seed] -&gt; setStdGen (mkStdGen seed)</span><br><span class="line">                        _ -&gt; return ()</span><br><span class="line"></span><br><span class="line">                    nps &lt;- replicateM n (randomRIO (minp, maxp))</span><br><span class="line">                    xs  &lt;- replicateM n (randomRIO (minX, maxX))</span><br><span class="line">                    ys  &lt;- replicateM n (randomRIO (minY, maxY))</span><br><span class="line">                    sds &lt;- replicateM n (randomRIO (minSD, maxSD))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> params = zip5 nps xs ys sds sds</span><br><span class="line"></span><br><span class="line">                    <span class="comment">-- first generate a set of points for each set of sample parameters</span></span><br><span class="line">                    ss &lt;- mapM (\(a,b,c,d,e) -&gt; generate2DSamples a b c d e) params</span><br><span class="line">                    <span class="keyword">let</span> points = concat ss</span><br><span class="line"></span><br><span class="line">                    <span class="comment">-- dump all the points into the file &quot;points&quot;</span></span><br><span class="line">                    hsamp &lt;- openFile <span class="string">&quot;points&quot;</span> <span class="type">WriteMode</span></span><br><span class="line">                    mapM_ (printPoint hsamp) points</span><br><span class="line">                    hClose hsamp</span><br><span class="line"></span><br><span class="line">                    encodeFile <span class="string">&quot;points.bin&quot;</span> points</span><br><span class="line"></span><br><span class="line">                    <span class="comment">-- generate the initial clusters by assigning each point to random</span></span><br><span class="line">                    <span class="comment">-- cluster.</span></span><br><span class="line">                    gen &lt;- newStdGen</span><br><span class="line">                    <span class="keyword">let</span></span><br><span class="line">                        rand_clusters = randomRs (<span class="number">0</span>,n-<span class="number">1</span>) gen :: [<span class="type">Int</span>]</span><br><span class="line">                        arr = accumArray (flip (:)) [] (<span class="number">0</span>,n-<span class="number">1</span>) $</span><br><span class="line">                                zip rand_clusters points</span><br><span class="line">                        clusters = map (uncurry makeCluster) (assocs arr)</span><br><span class="line">                    writeFile <span class="string">&quot;clusters&quot;</span> (show clusters)</span><br><span class="line"></span><br><span class="line">                    <span class="comment">-- so we can tell what the answer should be:</span></span><br><span class="line">                    writeFile <span class="string">&quot;params&quot;</span> (show params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">printPoint</span> :: <span class="type">Handle</span> -&gt; <span class="type">Point</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printPoint</span> h (<span class="type">Point</span> x y) = <span class="keyword">do</span></span><br><span class="line">                                hPutStr h (show x)</span><br><span class="line">                                hPutChar h <span class="string">&#x27; &#x27;</span></span><br><span class="line">                                hPutStr h (show y)</span><br><span class="line">                                hPutChar h <span class="string">&#x27;<span class="char escape_">\n</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title">generate2DSamples</span> :: <span class="type">Int</span>                 <span class="comment">-- number of samples to generate</span></span><br><span class="line">                  -&gt; <span class="type">Double</span> -&gt; <span class="type">Double</span>    <span class="comment">-- X and Y of the mean</span></span><br><span class="line">                  -&gt; <span class="type">Double</span> -&gt; <span class="type">Double</span>    <span class="comment">-- X and Y standard deviations</span></span><br><span class="line">                  -&gt; <span class="type">IO</span> [<span class="type">Point</span>]</span><br><span class="line"><span class="title">generate2DSamples</span> n mx my sdx sdy = <span class="keyword">do</span></span><br><span class="line">                                        gen &lt;- newStdGen</span><br><span class="line">                                        <span class="keyword">let</span> (genx, geny) = split gen</span><br><span class="line">                                            xsamples = normals&#x27; (mx,sdx) genx</span><br><span class="line">                                            ysamples = normals&#x27; (my,sdy) geny</span><br><span class="line">                                        return (zipWith <span class="type">Point</span> (take n xsamples) (take n ysamples))</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>关于 <code>getArgs</code>  函数，类型签名为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getArgs</span> :: <span class="type">IO</span> [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p>如果 main 函数为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">			args &lt;- getArgs</span><br><span class="line">			print args</span><br></pre></td></tr></table></figure>
<p>那么用 cabal 运行时，可以有如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cabal new-run Kmeans-parallel -- 1 2 3</span><br></pre></td></tr></table></figure>
<p>其中 <code>Kmeans-parallel</code>  是项目名，也是.cabal 文件中的 executable。而’–' 后面的内容就表示往可执行文件里传的 arguments。</p>
<p>就相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Kmeans-parallel 1 2 3</span><br></pre></td></tr></table></figure>
<p>而 <code>getArgs</code>  函数就可以获取到后面的 arguments 然后返回 “1 2 3”</p>
</li>
<li>
<p>关于随机数生成种子。有函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkStdGen</span> :: <span class="type">Int</span> -&gt; <span class="type">StdGen</span></span><br><span class="line"><span class="title">setStdGen</span> :: <span class="type">MonadIO</span> m =&gt; <span class="type">StdGen</span> -&gt; m ()</span><br></pre></td></tr></table></figure>
<p>不知道具体用法，本质上就是在设置随机数生成种子。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">randomRIO</span> :: (<span class="type">Random</span> a, <span class="type">MonadIO</span> m) =&gt; (a, a) -&gt; m a</span><br></pre></td></tr></table></figure>
<p>用法就是输入一个上下界，然后返回一个范围内随机值。然后 Int 和 Double 啥的都是 Random 的 instance，故随便用。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">randomRs</span> :: (<span class="type">Random</span> a, <span class="type">RandomGen</span> g) =&gt; (a, a) -&gt; g -&gt; [a]</span><br></pre></td></tr></table></figure>
<p>用法就是可以多传一个随机数种子进去，譬如如下用法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">randomRs</span> (<span class="number">1</span>, <span class="number">10</span>) (mkStdGen <span class="number">0725</span>)</span><br></pre></td></tr></table></figure>
<p>就是可以的，但是会返回一个无限长的随机数列。实际中往往需要利用<strong> lazy evaluating</strong> 的特性，用法如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">10</span> $ randomRs (<span class="number">1</span>, <span class="number">10</span>) (mkStdGen <span class="number">0725</span>)</span><br></pre></td></tr></table></figure>
<p>就会返回一个长度为 10，范围在 1~10 之间的随机数列。</p>
</li>
<li>
<p>关于 <code>replicateM</code>  函数。首先 replicate 函数很好理解：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">replicate</span> :: <span class="type">Int</span> -&gt; a -&gt; [a]</span><br><span class="line"></span><br><span class="line"><span class="title">replicate</span> <span class="number">3</span> <span class="type">True</span> = [<span class="type">True</span>, <span class="type">True</span>, <span class="type">True</span>]</span><br></pre></td></tr></table></figure>
<p>就是把一个值重复若干遍。但 <code>replicateM</code>  后面那个 M 的意思实际上是 Monad 的意思：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">replicateM</span> :: <span class="type">Applicative</span> m =&gt; <span class="type">Int</span> -&gt; m a -&gt; m [a]</span><br></pre></td></tr></table></figure>
<p>这里要考虑下 Monad 的含义了。我们有两种说法：<strong>Monadic action</strong> 和<strong> Monadic value</strong>。像 <code>Maybe</code>  这样的 Monad，我们就把它全看作是 Monad value，因为它没有 side effect。</p>
<p>而 <code>IO</code>  Monad 就不一样，一方面它可能有返回值譬如 <code>IO String</code> ，那么那个 String 就体现了其 Monadic value 的一面；另一方面它可能有 side effect，譬如往控制台读写内容，这就体现了其 Monadic action 的一面。所以我们也用<strong> do-notation</strong> 作为 monad 的一个语法糖，即可以看作是完成了一系列动作。</p>
<p>常用的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> ...</span><br></pre></td></tr></table></figure>
<p>就表明 main 函数我们不关心其返回值（记为 <code>IO ()</code> ）而只关心他做了什么，即用 do-notation 表示。</p>
<p>而 <code>replicateM</code>  实际上就是把后面的 m a 的 Monadic action 重复做若干次，然后把 Monadic value 返回一个数组。</p>
<p>譬如 replicateM 3 main 的返回值实际上就是 IO [(), (), ()]。</p>
<p>如果实在不关心返回值，只关注 action，也可以使用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">replicateM_</span> :: <span class="type">Applicative</span> m =&gt; <span class="type">Int</span> -&gt; m a -&gt; m ()</span><br></pre></td></tr></table></figure>
<p>这在后面介绍 <code>mapM</code>  和 <code>mapM_</code> 时是一样的。</p>
</li>
</ol>
<h1 id="kmeans"><a class="markdownIt-Anchor" href="#kmeans">#</a> Kmeans</h1>
<p>这部分是最关键的，代码如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables, BangPatterns #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Kmeans <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- K-Means sample from &quot;Parallel and Concurrent Programming in Haskell&quot;</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- With three versions:</span></span><br><span class="line"><span class="comment">--   [ kmeans_seq   ]  a sequential version</span></span><br><span class="line"><span class="comment">--   [ kmeans_strat ]  a parallel version using Control.Parallel.Strategies</span></span><br><span class="line"><span class="comment">--   [ kmeans_par   ]  a parallel version using Control.Monad.Par</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Usage (sequential):</span></span><br><span class="line"><span class="comment">--   $ ./kmeans seq</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Usage (Strategies):</span></span><br><span class="line"><span class="comment">--   $ ./kmeans strat 600 +RTS -N4</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Usage (Par monad):</span></span><br><span class="line"><span class="comment">--   $ ./kmeans par 600 +RTS -N4</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Usage (divide-and-conquer / Par monad):</span></span><br><span class="line"><span class="comment">--   $ ./kmeans divpar 7 +RTS -N4</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Usage (divide-and-conquer / Eval monad):</span></span><br><span class="line"><span class="comment">--   $ ./kmeans diveval 7 +RTS -N4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"><span class="keyword">import</span> KMeansCore</span><br><span class="line"><span class="keyword">import</span> Data.Array</span><br><span class="line"><span class="keyword">import</span> Data.Array.Unsafe <span class="keyword">as</span> Unsafe</span><br><span class="line"><span class="keyword">import</span> Text.Printf</span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="keyword">import</span> Data.Function</span><br><span class="line"><span class="keyword">import</span> Data.Binary (<span class="title">decodeFile</span>)</span><br><span class="line"><span class="keyword">import</span> Debug.Trace</span><br><span class="line"><span class="keyword">import</span> Control.Parallel.Strategies <span class="keyword">as</span> Strategies</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Par <span class="keyword">as</span> Par</span><br><span class="line"><span class="keyword">import</span> Control.DeepSeq</span><br><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> Data.Time.Clock</span><br><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line"><span class="keyword">import</span> Control.Concurrent</span><br><span class="line"><span class="keyword">import</span> Control.Monad.ST</span><br><span class="line"><span class="keyword">import</span> Data.Array.ST</span><br><span class="line"><span class="keyword">import</span> System.Mem</span><br><span class="line"><span class="keyword">import</span> Data.Maybe</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector <span class="keyword">as</span> Vector</span><br><span class="line"><span class="keyword">import</span> Data.Vector (<span class="type">Vector</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector.Mutable <span class="keyword">as</span> MVector</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- main: read input files, time calculation</span></span><br><span class="line"></span><br><span class="line"><span class="title">kmeansMain</span> :: [<span class="type">String</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">kmeansMain</span> args = runInUnboundThread $ <span class="keyword">do</span></span><br><span class="line">                                            points &lt;- decodeFile <span class="string">&quot;points.bin&quot;</span></span><br><span class="line">                                            clusters &lt;- read `fmap` readFile <span class="string">&quot;clusters&quot;</span></span><br><span class="line">                                            <span class="keyword">let</span> nclusters = length clusters</span><br><span class="line">                                            npoints &lt;- evaluate (length points)</span><br><span class="line">                                            performGC</span><br><span class="line">                                            t0 &lt;- getCurrentTime</span><br><span class="line">                                            final_clusters &lt;- <span class="keyword">case</span> args <span class="keyword">of</span></span><br><span class="line">                                                [<span class="string">&quot;seq&quot;</span>       ] -&gt; kmeans_seq               nclusters points clusters</span><br><span class="line">                                                [<span class="string">&quot;strat&quot;</span>,   n] -&gt; kmeans_strat    (read n) nclusters points clusters</span><br><span class="line">                                                _other -&gt; error <span class="string">&quot;args&quot;</span></span><br><span class="line">                                            t1 &lt;- getCurrentTime</span><br><span class="line">                                            print final_clusters</span><br><span class="line">                                            printf <span class="string">&quot;Total time: %.2f\n&quot;</span> (realToFrac (diffUTCTime t1 t0) :: <span class="type">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- K-Means: repeatedly step until convergence (sequential)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;kmeans_seq</span></span><br><span class="line"><span class="title">kmeans_seq</span> :: <span class="type">Int</span> -&gt; [<span class="type">Point</span>] -&gt; [<span class="type">Cluster</span>] -&gt; <span class="type">IO</span> [<span class="type">Cluster</span>]</span><br><span class="line"><span class="title">kmeans_seq</span> nclusters points clusters =</span><br><span class="line">  <span class="keyword">let</span></span><br><span class="line">      loop :: <span class="type">Int</span> -&gt; [<span class="type">Cluster</span>] -&gt; <span class="type">IO</span> [<span class="type">Cluster</span>]</span><br><span class="line">      loop n clusters | n &gt; tooMany = <span class="keyword">do</span>                  <span class="comment">-- &lt;1&gt;</span></span><br><span class="line">        putStrLn <span class="string">&quot;giving up.&quot;</span></span><br><span class="line">        return clusters</span><br><span class="line">      loop n clusters = <span class="keyword">do</span></span><br><span class="line">        printf <span class="string">&quot;iteration %d\n&quot;</span> n</span><br><span class="line">        putStr (unlines (map show clusters))</span><br><span class="line">        <span class="keyword">let</span> clusters&#x27; = step nclusters clusters points    <span class="comment">-- &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> clusters&#x27; == clusters                          <span class="comment">-- &lt;3&gt;</span></span><br><span class="line">           <span class="keyword">then</span> return clusters</span><br><span class="line">           <span class="keyword">else</span> loop (n + <span class="number">1</span>) clusters&#x27;</span><br><span class="line">  <span class="keyword">in</span></span><br><span class="line">  loop <span class="number">0</span> clusters</span><br><span class="line"></span><br><span class="line"><span class="title">tooMany</span> = <span class="number">80</span></span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- K-Means: repeatedly step until convergence (Strategies)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;kmeans_strat</span></span><br><span class="line"><span class="title">kmeans_strat</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; [<span class="type">Point</span>] -&gt; [<span class="type">Cluster</span>] -&gt; <span class="type">IO</span> [<span class="type">Cluster</span>]</span><br><span class="line"><span class="title">kmeans_strat</span> numChunks nclusters points clusters =</span><br><span class="line">  <span class="keyword">let</span></span><br><span class="line">      chunks = split numChunks points                            <span class="comment">-- &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">      loop :: <span class="type">Int</span> -&gt; [<span class="type">Cluster</span>] -&gt; <span class="type">IO</span> [<span class="type">Cluster</span>]</span><br><span class="line">      loop n clusters | n &gt; tooMany = <span class="keyword">do</span></span><br><span class="line">        printf <span class="string">&quot;giving up.&quot;</span></span><br><span class="line">        return clusters</span><br><span class="line">      loop n clusters = <span class="keyword">do</span></span><br><span class="line">        printf <span class="string">&quot;iteration %d\n&quot;</span> n</span><br><span class="line">        putStr (unlines (map show clusters))</span><br><span class="line">        <span class="keyword">let</span> clusters&#x27; = parSteps_strat nclusters clusters chunks <span class="comment">-- &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> clusters&#x27; == clusters</span><br><span class="line">           <span class="keyword">then</span> return clusters</span><br><span class="line">           <span class="keyword">else</span> loop (n+<span class="number">1</span>) clusters&#x27;</span><br><span class="line">  <span class="keyword">in</span></span><br><span class="line">  loop <span class="number">0</span> clusters</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;split</span></span><br><span class="line"><span class="title">split</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [[a]]</span><br><span class="line"><span class="title">split</span> numChunks xs = chunk (length xs `quot` numChunks) xs</span><br><span class="line"></span><br><span class="line"><span class="title">chunk</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [[a]]</span><br><span class="line"><span class="title">chunk</span> n [] = []</span><br><span class="line"><span class="title">chunk</span> n xs = <span class="keyword">as</span> : chunk n bs</span><br><span class="line">  <span class="keyword">where</span> (<span class="keyword">as</span>,bs) = splitAt n xs</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Perform one step of the K-Means algorithm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;step</span></span><br><span class="line"><span class="title">step</span> :: <span class="type">Int</span> -&gt; [<span class="type">Cluster</span>] -&gt; [<span class="type">Point</span>] -&gt; [<span class="type">Cluster</span>]</span><br><span class="line"><span class="title">step</span> nclusters clusters points</span><br><span class="line">   = makeNewClusters (assign nclusters clusters points)</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;assign</span></span><br><span class="line"><span class="title">assign</span> :: <span class="type">Int</span> -&gt; [<span class="type">Cluster</span>] -&gt; [<span class="type">Point</span>] -&gt; <span class="type">Vector</span> <span class="type">PointSum</span></span><br><span class="line"><span class="title">assign</span> nclusters clusters points = <span class="type">Vector</span>.create $ <span class="keyword">do</span></span><br><span class="line">    vec &lt;- <span class="type">MVector</span>.replicate nclusters (<span class="type">PointSum</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        addpoint p = <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">let</span> c = nearest p; cid = clId c</span><br><span class="line">          ps &lt;- <span class="type">MVector</span>.read vec cid</span><br><span class="line">          <span class="type">MVector</span>.write vec cid $! addToPointSum ps p</span><br><span class="line"></span><br><span class="line">    mapM_ addpoint points</span><br><span class="line">    return vec</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">  nearest p = fst $ minimumBy (compare `on` snd)</span><br><span class="line">                        [ (c, sqDistance (clCent c) p) | c &lt;- clusters ]</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">PointSum</span> = <span class="type">PointSum</span> <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Int</span> <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Double</span> <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Double</span></span></span><br><span class="line">	<span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">NFData</span> <span class="type">PointSum</span> <span class="keyword">where</span></span></span><br><span class="line">  rnf (<span class="type">PointSum</span> count xs ys) = () <span class="comment">-- all fields are strict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;addToPointSum</span></span><br><span class="line"><span class="title">addToPointSum</span> :: <span class="type">PointSum</span> -&gt; <span class="type">Point</span> -&gt; <span class="type">PointSum</span></span><br><span class="line"><span class="title">addToPointSum</span> (<span class="type">PointSum</span> count xs ys) (<span class="type">Point</span> x y)</span><br><span class="line">  = <span class="type">PointSum</span> (count+<span class="number">1</span>) (xs + x) (ys + y)</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;pointSumToCluster</span></span><br><span class="line"><span class="title">pointSumToCluster</span> :: <span class="type">Int</span> -&gt; <span class="type">PointSum</span> -&gt; <span class="type">Cluster</span></span><br><span class="line"><span class="title">pointSumToCluster</span> i (<span class="type">PointSum</span> count xs ys) =</span><br><span class="line">  <span class="type">Cluster</span> &#123; clId    = i</span><br><span class="line">          , clCent  = <span class="type">Point</span> (xs / fromIntegral count) (ys / fromIntegral count)</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;addPointSums</span></span><br><span class="line"><span class="title">addPointSums</span> :: <span class="type">PointSum</span> -&gt; <span class="type">PointSum</span> -&gt; <span class="type">PointSum</span></span><br><span class="line"><span class="title">addPointSums</span> (<span class="type">PointSum</span> c1 x1 y1) (<span class="type">PointSum</span> c2 x2 y2)</span><br><span class="line">  = <span class="type">PointSum</span> (c1+c2) (x1+x2) (y1+y2)</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;combine</span></span><br><span class="line"><span class="title">combine</span> :: <span class="type">Vector</span> <span class="type">PointSum</span> -&gt; <span class="type">Vector</span> <span class="type">PointSum</span> -&gt; <span class="type">Vector</span> <span class="type">PointSum</span></span><br><span class="line"><span class="title">combine</span> = <span class="type">Vector</span>.zipWith addPointSums</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;parSteps_strat</span></span><br><span class="line"><span class="title">parSteps_strat</span> :: <span class="type">Int</span> -&gt; [<span class="type">Cluster</span>] -&gt; [[<span class="type">Point</span>]] -&gt; [<span class="type">Cluster</span>]</span><br><span class="line"><span class="title">parSteps_strat</span> nclusters clusters pointss</span><br><span class="line">  = makeNewClusters $</span><br><span class="line">      foldr1 combine $</span><br><span class="line">          (map (assign nclusters clusters) pointss</span><br><span class="line">            `using` parList rseq)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- &lt;&lt;makeNewClusters</span></span><br><span class="line"><span class="title">makeNewClusters</span> :: <span class="type">Vector</span> <span class="type">PointSum</span> -&gt; [<span class="type">Cluster</span>]</span><br><span class="line"><span class="title">makeNewClusters</span> vec =</span><br><span class="line">  [ pointSumToCluster i ps</span><br><span class="line">  | (i,ps@(<span class="type">PointSum</span> count _ _)) &lt;- zip [<span class="number">0</span>..] (<span class="type">Vector</span>.toList vec)</span><br><span class="line">  , count &gt; <span class="number">0</span></span><br><span class="line">  ]</span><br><span class="line"><span class="comment">-- &gt;&gt;</span></span><br><span class="line">                        <span class="comment">-- v. important: filter out any clusters that have</span></span><br><span class="line">                        <span class="comment">-- no points.  This can happen when a cluster is not</span></span><br><span class="line">                        <span class="comment">-- close to any points.  If we leave these in, then</span></span><br><span class="line">                        <span class="comment">-- the NaNs mess up all the future calculations.</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>关于 <code>Data.Vector</code> 。感觉上就像类似 C++ 里的 STL，vector。但是 Haskell 里的 Vector 有多种属性，可以分为 Boxed 和 Unboxed，mutable 和 immutable 等。可以看到原代码也引用了 <code>Data.Vector.Mutable</code> ，即可变 Vector。首先看一下我查到的解释：</p>
<blockquote>
<p>There are two different varieties of vectors: immutable and mutable. Immutable vectors (such as provided by the  <code>Data.Vector</code>  module) are essentially swappable with normal lists in Haskell, though with drastically different performance characteristics (discussed below). The high-level API is similar to lists, it implements common typeclasses like  <code>Functor</code>  and  <code>Foldable</code> , and plays quite nicely with parallel code.</p>
<p>By contrast, mutable vectors are much closer to C-style arrays. Operations working on these values must live in the  <code>IO</code>  or  <code>ST</code>  monads (see  <code>PrimMonad</code>  below for more details). Concurrent access from multiple threads has all of the normal concerns of shared mutable state. And perhaps most importantly for usage: mutable vectors can be <em>much</em> more efficient for certain use cases.</p>
</blockquote>
<p>简单地理解可以认为 immutable 的 Vector 就和普通的 List 的是一一对应的，它是一种不支持改写的数据类型。而 mutable 的 Vector 是支持随机读写的，但是需要套在一个 Monad 里，可以认为写入 / 修改操作是一个 Monadic action，且会导致该操作前后读到的内容不同。即破坏了纯度 pure。（否则一个变量一旦绑定后，无论多少次作为纯函数的输入，输出都是一样的）而在多线程中，mutablke vectors 是可以多个线程修改的，且效率高很多。看一个例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector <span class="keyword">as</span> V</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector.Mutable <span class="keyword">as</span> MV</span><br><span class="line">&gt;&gt;&gt; mv &lt;- <span class="type">V</span>.thaw $ <span class="type">V</span>.fromList ([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] :: [<span class="type">Integer</span>])</span><br><span class="line">&gt;&gt;&gt; mv&#x27; &lt;- <span class="type">MV</span>.grow mv <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; <span class="type">MV</span>.write mv&#x27; <span class="number">3</span> <span class="number">999</span></span><br><span class="line">&gt;&gt;&gt; <span class="type">MV</span>.write mv&#x27; <span class="number">4</span> <span class="number">777</span></span><br><span class="line">&gt;&gt;&gt; <span class="type">V</span>.freeze mv&#x27;</span><br><span class="line">[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">999</span>,<span class="number">777</span>]</span><br></pre></td></tr></table></figure>
<p>其中 thaw 函数就是将一个 vector 生成了对应的 mutable 版本，然后 grow 是用来增长长度，write 用来写，freeze 就是把 mutable 的再冻结成 immutable 的。</p>
<p>而原代码使用的 <code>MVector.replicate</code>  也是就是将后面的元素重复若干次，形成一个 mutable vector。</p>
</li>
<li>
<p>关于比较的东西，首先有 <code>Ordering</code>  type，它只有三个常数值：LT, EQ, GT。就是小于，等于，大于。然后看下 compare 和 minimumBy 的类型签名：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compare</span> :: <span class="type">Ord</span> a =&gt; a -&gt; a -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="title">minimumBy</span> :: (a -&gt; a -&gt; <span class="type">Ordering</span>) -&gt; <span class="type">Vector</span> a -&gt; a</span><br></pre></td></tr></table></figure>
<p>实际上就是给了偏序类的元素一个比较函数，以及给出一个比较函数就能得到 Vector 里的最小值，然后下面这个写法很有意思</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(compare `on` snd) :: <span class="type">Ord</span> a1 =&gt; (a2, a1) -&gt; (a2, a1) -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="title">on</span> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; a -&gt; c)</span><br><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</span><br></pre></td></tr></table></figure>
<p>就是 on 这个函数，可以认为是把一个函数变成了另一个（额废话），有点像二元的（.)。</p>
<p>原代码中的 nearest 函数，实际上就是找点 p 最近的一个 cluster。</p>
</li>
<li>
<p>关于 <code>$!</code>  符号，实际上是个非常严格的符号，即：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> $! x = x `seq` f x</span><br></pre></td></tr></table></figure>
<p>即先 urge 地把 x evaluate 了，再送入 f。</p>
</li>
<li>
<p>关于 <code>mapM</code>  和 <code>mapM_</code> 。首先 <code>mapM</code>  可以看作 <code>map</code>  的扩展。考虑到类型签名：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">mapM</span> :: (a -&gt; m b) -&gt; t a -&gt; m (t b)</span><br></pre></td></tr></table></figure>
<p>就是 <code>mapM</code>  实际上是输入一个类型为 a -&gt; m b 的 Monadic action，然后对 t a 中每个值都作用一次，然后返回一组 Monadic value 返回值。譬如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mapM (\s -&gt; <span class="keyword">do</span> print <span class="number">3</span>; return (s + <span class="number">1</span>)) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>就做了三次 Monadic action，返回了 monadic action 后的值。</p>
<p>然而类似 <code>replicateM_</code> ，有时我们不关心 Monadic value，即返回是 [(), (), ()] 时，就可以使用 <code>mapM_</code> ，直接不返回 Monadic value，只重复 Monadic action：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mapM_ (\_ -&gt; <span class="keyword">do</span> print <span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>然后原代码中，assign 函数中的子函数 addpoint 实际上类型是 Point -&gt; m ()，就是一个完全的 Monadic action，作用就是把输入的 Point 加到离他最近的一个 Cluster 里。</p>
</li>
<li>
<p>关于 <code>makeNewCluster</code>  中的 zip 写法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zip</span> [<span class="number">0</span> ..] (<span class="type">Vector</span>.toList vec)</span><br></pre></td></tr></table></figure>
<p>其中，[0 …] 是个无限长的 List，然后很好地利用了 zip 函数和 lazy evaluating 的特点，给后面的 vector 也标了个序号。</p>
<p>然后形如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> loop = <span class="keyword">do</span></span><br><span class="line">		....</span><br><span class="line">	<span class="keyword">in</span></span><br><span class="line"><span class="title">loop</span> n clusters</span><br></pre></td></tr></table></figure>
<p>也是个写循环的很经典的写法。</p>
</li>
<li>
<p>看到 <code>assign</code>  函数的作用实际上是给出 clusters 的数量，然后一个 Clusters 的 List，一个 Point 的 List，然后返回一个长度为 clusters 数量的 Vector PointSum。就是把 Points 分类到 clusters 里，然后加到 clusters 里。一个 PointSum 就是一个 point 的集合全加起来。最主要就是下面这行代码：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mapM_</span> addpoint points</span><br></pre></td></tr></table></figure>
<p>然后这就是我们考虑 parallel programming 的地方。</p>
<p>一个基本的想法就是把 points 划分成若干个 chunks，然后分别在各个 chunks 上进行 mapM_操作。然后原代码中的 <code>chunk</code>  函数就是在进行划分 chunks 这个操作。</p>
<p>然后 <code>kmeans_strat</code>  函数和 <code>kmeans_seq</code>  函数不同之处就在于调用的是 <code>parSteps_strat</code>  函数。</p>
<p>在 <code>parSteps_strat</code>  函数中，map 操作使用了：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (assign nclusters clusters) pointss `using` parList rseq</span><br></pre></td></tr></table></figure>
<p>就是在 parallel 地把 nChunks（chunks 的个数）个 point 集合都 assign 了，然后再合并起来。</p>
<p><code>foldr1</code>  函数和 <code>foldr</code>  函数的唯一区别就是不需要提供初始值，默认列表第一个就是初始值。</p>
</li>
</ol>
<h1 id="实验和表现"><a class="markdownIt-Anchor" href="#实验和表现">#</a> 实验和表现：</h1>
<h2 id="生成数据"><a class="markdownIt-Anchor" href="#生成数据">#</a> 生成数据</h2>
<p>写 <code>Main</code>  里的 main 函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Main <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> GenSample <span class="keyword">as</span> GS</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Kmeans <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">            putStrLn <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">            args &lt;- getArgs</span><br><span class="line">            print args</span><br><span class="line">            <span class="type">GS</span>.genMain args</span><br><span class="line">            <span class="comment">-- K.kmeansMain args</span></span><br></pre></td></tr></table></figure>
<p>然后输入：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cabal</span> new-run <span class="type">Kmeans</span>-parallel <span class="comment">-- 5 500000 100000 1010</span></span><br></pre></td></tr></table></figure>
<p>就生成了 50000~100000 个随机点，随机数种子是 1010，然后随机生成了 5 个初始 cluster。</p>
<h2 id="无并发情况"><a class="markdownIt-Anchor" href="#无并发情况">#</a> 无并发情况</h2>
<p>注释掉 main 函数里：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">            putStrLn <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">            args &lt;- getArgs</span><br><span class="line">            print args</span><br><span class="line">            <span class="comment">-- GS.genMain args</span></span><br><span class="line">            <span class="type">K</span>.kmeansMain args</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cabal</span> new-run <span class="type">Kmeans</span>-parallel <span class="comment">-- seq</span></span><br></pre></td></tr></table></figure>
<p>17 次迭代后结果如下：</p>
<p><img data-src="3.png" alt="3"></p>
<h2 id="双核parallel"><a class="markdownIt-Anchor" href="#双核parallel">#</a> 双核 parallel</h2>
<p>注释掉 main 函数里：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">            putStrLn <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">            args &lt;- getArgs</span><br><span class="line">            print args</span><br><span class="line">            <span class="comment">-- GS.genMain args</span></span><br><span class="line">            <span class="type">K</span>.kmeansMain args</span><br></pre></td></tr></table></figure>
<p>输入（64 代表分成 64 个 chunks）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cabal</span> new-run <span class="type">Kmeans</span>-parallel <span class="comment">-- strat 64 +RTS -N2 -l</span></span><br></pre></td></tr></table></figure>
<p>17 次迭代后结果如下：</p>
<p><img data-src="4.png" alt="4"></p>
<p>线程运行情况如下：</p>
<p><img data-src="5.png" alt="5"></p>
<h2 id="三核parallel"><a class="markdownIt-Anchor" href="#三核parallel">#</a> 三核 parallel</h2>
<p>注释掉 main 函数里：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">            putStrLn <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">            args &lt;- getArgs</span><br><span class="line">            print args</span><br><span class="line">            <span class="comment">-- GS.genMain args</span></span><br><span class="line">            <span class="type">K</span>.kmeansMain args</span><br></pre></td></tr></table></figure>
<p>输入（64 代表分成 64 个 chunks）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cabal</span> new-run <span class="type">Kmeans</span>-parallel <span class="comment">-- strat 64 +RTS -N3 -l</span></span><br></pre></td></tr></table></figure>
<p>17 次迭代后结果如下：</p>
<p><img data-src="6.png" alt="6"></p>
<p>线程运行情况如下：</p>
<p><img data-src="7.png" alt="7"></p>
<h2 id="四核parallel"><a class="markdownIt-Anchor" href="#四核parallel">#</a> 四核 parallel</h2>
<p>注释掉 main 函数里：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">            putStrLn <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">            args &lt;- getArgs</span><br><span class="line">            print args</span><br><span class="line">            <span class="comment">-- GS.genMain args</span></span><br><span class="line">            <span class="type">K</span>.kmeansMain args</span><br></pre></td></tr></table></figure>
<p>输入（64 代表分成 64 个 chunks）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cabal</span> new-run <span class="type">Kmeans</span>-parallel <span class="comment">-- strat 64 +RTS -N4 -l</span></span><br></pre></td></tr></table></figure>
<p>17 次迭代后结果如下：</p>
<p><img data-src="8.png" alt="8"></p>
<p>线程运行情况如下：</p>
<p><img data-src="9.png" alt="9"></p>
<hr>
<p>我这后面核多了也没啥提升了 hhh</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2025-03-30 09:06:20" itemprop="dateModified" datetime="2025-03-30T09:06:20+08:00">2025-03-30</time>
  </span>
  <span id="2022/08/28/关于Haskell对Kmeans算法parallel并行实现的注释/" class="item leancloud_visitors" data-flag-title="关于 Haskell 对 Kmeans 算法 parallel 并行实现的注释" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>SuBonan <i class="ic i-at"><em>@</em></i>やがて、平凡な人になる
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://sugarsbn.github.io/2022/08/28/%E5%85%B3%E4%BA%8EHaskell%E5%AF%B9Kmeans%E7%AE%97%E6%B3%95parallel%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/" title="关于 Haskell 对 Kmeans 算法 parallel 并行实现的注释">http://sugarsbn.github.io/2022/08/28/关于Haskell对Kmeans算法parallel并行实现的注释/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/07/27/MTZ%E7%BA%A6%E6%9D%9F/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;i.imgtg.com&#x2F;2023&#x2F;01&#x2F;12&#x2F;Q5He6.png" title="TSP问题中消除子圈的MTZ约束">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> - 数学杂记</span>
  <h3>TSP问题中消除子圈的MTZ约束</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/10/25/HoTT/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;i.imgtg.com&#x2F;2023&#x2F;01&#x2F;12&#x2F;QUBUG.jpg" title="Homotopy Type Theory">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> - 数学杂记</span>
  <h3>Homotopy Type Theory</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kmeanscore"><span class="toc-number">1.</span> <span class="toc-text"> KMeansCore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gensample"><span class="toc-number">2.</span> <span class="toc-text"> GenSample</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kmeans"><span class="toc-number">3.</span> <span class="toc-text"> Kmeans</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%92%8C%E8%A1%A8%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text"> 实验和表现：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text"> 生成数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5"><span class="toc-number">4.2.</span> <span class="toc-text"> 无并发情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%A0%B8parallel"><span class="toc-number">4.3.</span> <span class="toc-text"> 双核 parallel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A0%B8parallel"><span class="toc-number">4.4.</span> <span class="toc-text"> 三核 parallel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%A0%B8parallel"><span class="toc-number">4.5.</span> <span class="toc-text"> 四核 parallel</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/2020/10/06/%E5%85%B3%E4%BA%8Ejava%E5%9F%9F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E6%80%81%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BC%BA%E9%99%B7/" rel="bookmark" title="关于java域和静态方法不支持多态导致的缺陷">关于java域和静态方法不支持多态导致的缺陷</a></li><li><a href="/2020/11/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/" rel="bookmark" title="基数排序">基数排序</a></li><li><a href="/2021/06/09/C%20C++%20%E8%AF%AD%E6%B3%95/" rel="bookmark" title="C-C++语法">C-C++语法</a></li><li><a href="/2021/10/20/%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/" rel="bookmark" title="类型和程序设计语言">类型和程序设计语言</a></li><li><a href="/2021/11/02/%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%BB%AD/" rel="bookmark" title="类型和程序设计语言_续">类型和程序设计语言_续</a></li><li><a href="/2022/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="操作系统">操作系统</a></li><li><a href="/2022/04/21/linker-symtable/" rel="bookmark" title="链接（基于x86-64下标准ELF格式）">链接（基于x86-64下标准ELF格式）</a></li><li class="active"><a href="/2022/08/28/%E5%85%B3%E4%BA%8EHaskell%E5%AF%B9Kmeans%E7%AE%97%E6%B3%95parallel%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/" rel="bookmark" title="关于Haskell对Kmeans算法parallel并行实现的注释">关于Haskell对Kmeans算法parallel并行实现的注释</a></li><li><a href="/2023/01/05/C-%E6%95%B0%E7%BB%84/" rel="bookmark" title="C++中数组和内存分布">C++中数组和内存分布</a></li><li><a href="/2023/01/11/Machine-Learning/" rel="bookmark" title="Machine Learning 机器学习">Machine Learning 机器学习</a></li><li><a href="/2023/01/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%90%AB%E4%B9%89/" rel="bookmark" title="图形学中的矩阵含义">图形学中的矩阵含义</a></li><li><a href="/2023/02/01/%E7%82%B9%E7%BA%BF%E9%9D%A2%E7%9A%84%E6%8F%92%E5%80%BC/" rel="bookmark" title="点线面的插值">点线面的插值</a></li><li><a href="/2023/02/11/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" rel="bookmark" title="光照模型">光照模型</a></li><li><a href="/2023/02/11/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E4%BC%98%E5%8C%96/" rel="bookmark" title="汇编语言乱七八糟的优化">汇编语言乱七八糟的优化</a></li><li><a href="/2023/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="bookmark" title="计算机网络">计算机网络</a></li><li><a href="/2023/06/14/Database/" rel="bookmark" title="Introduction to Database">Introduction to Database</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="SuBonan"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">SuBonan</p>
  <div class="description" itemprop="description">やがて、平凡な人になる <br><a target="_blank" rel="noopener" href="http://www.subonan.com/computer-graphics"> 图形学作业请点这里 </a></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">116</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">10</span>
        <span class="name">categories</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1Z2FyU0JO" title="https:&#x2F;&#x2F;github.com&#x2F;SugarSBN"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2022/07/27/MTZ%E7%BA%A6%E6%9D%9F/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/10/25/HoTT/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2020/11/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E9%9B%86%E5%90%88%E9%83%A8%E5%88%86/" title="离散数学-集合部分">离散数学-集合部分</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/" title="In - 程序语言理论">- 程序语言理论</a>
</div>

    <span><a href="/2021/09/27/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%EF%BC%88%E7%BB%AD%EF%BC%89/" title="程序设计语言的形式语义（续）">程序设计语言的形式语义（续）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="In - 计算机基础">- 计算机基础</a>
</div>

    <span><a href="/2023/01/05/C-%E6%95%B0%E7%BB%84/" title="C++中数组和内存分布">C++中数组和内存分布</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%A4%96%E8%AF%AD/" title="In - 外语">- 外语</a>
</div>

    <span><a href="/2020/10/14/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/" title="大英帝国語筆記">大英帝国語筆記</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%A4%96%E8%AF%AD/" title="In - 外语">- 外语</a>
</div>

    <span><a href="/2021/02/04/%E6%97%A5%E6%9C%AC%E8%AF%AD%E9%87%8D%E7%82%B9/" title="日本語重点">日本語重点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2023/04/27/%E5%A4%8D%E6%9D%82%E6%80%A7%E8%AF%81%E6%98%8E%E6%8A%80%E5%B7%A7/" title="Complexity Theory中一些基础定理的证明">Complexity Theory中一些基础定理的证明</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%82%E6%84%9F/" title="In - 杂感">- 杂感</a>
</div>

    <span><a href="/2019/08/21/%E7%BA%AA%E5%BF%B5%E5%BE%90%E5%AD%90%E7%84%93/" title="纪念徐子焓">纪念徐子焓</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2025/03/31/2025-3-31-sylow-theorem/" title="Sylow Theorem">Sylow Theorem</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="In - 计算机基础">- 计算机基础</a>
</div>

    <span><a href="/2023/01/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%90%AB%E4%B9%89/" title="图形学中的矩阵含义">图形学中的矩阵含义</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E5%AD%A6%E6%9D%82%E8%AE%B0/" title="In - 数学杂记">- 数学杂记</a>
</div>

    <span><a href="/2022/06/10/lambda-cube/" title="Lambda Cube">Lambda Cube</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SuBonan @ SuBonan</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/08/28/关于Haskell对Kmeans算法parallel并行实现的注释/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
